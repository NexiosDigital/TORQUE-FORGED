import { createClient } from "@supabase/supabase-js";
import { dataAPIService } from "./DataAPIService";
import { ImageUploadService } from "./ImageUploadService";

/**
 * PostService - VERS√ÉO CORRIGIDA E VERIFICADA
 * - M√©todo createPost corrigido e com debug melhorado
 * - Verifica√ß√µes de permiss√£o adicionadas
 * - Error handling melhorado
 * - Logs detalhados para debug
 */

const supabaseUrl = process.env.REACT_APP_SUPABASE_URL;
const supabaseAnonKey = process.env.REACT_APP_SUPABASE_ANON_KEY;

// Cliente admin (mant√©m para opera√ß√µes administrativas)
const adminClient = createClient(supabaseUrl, supabaseAnonKey);

export class PostService {
	/**
	 * ======================================
	 * M√âTODOS P√öBLICOS - AGORA COM DATA API
	 * ======================================
	 */

	// Posts em destaque - Data API com cache HTTP
	static async getFeaturedPosts() {
		try {
			const data = await dataAPIService.getFeaturedPosts();

			// Otimizar URLs das imagens para performance
			return (data || []).map((post) => ({
				...post,
				image_url: this.getOptimizedImageUrl(post.image_path, post.image_url),
			}));
		} catch (error) {
			console.error("‚ùå PostService.getFeaturedPosts (Data API) error:", error);

			// Fallback para m√©todo SDK se Data API falhar
			return this.getFeaturedPostsSDK();
		}
	}

	// Todos os posts - Data API otimizada
	static async getAllPosts() {
		try {
			const data = await dataAPIService.getAllPosts();

			// Otimizar URLs das imagens para performance
			return (data || []).map((post) => ({
				...post,
				image_url: this.getOptimizedImageUrl(post.image_path, post.image_url),
			}));
		} catch (error) {
			console.error("‚ùå PostService.getAllPosts (Data API) error:", error);
			return this.getAllPostsSDK();
		}
	}

	// Posts por categoria - Data API com cache
	static async getPostsByCategory(categoryId) {
		if (!categoryId) {
			throw new Error("Category ID √© obrigat√≥rio");
		}

		try {
			const data = await dataAPIService.getPostsByCategory(categoryId);

			// Otimizar URLs das imagens para performance
			return (data || []).map((post) => ({
				...post,
				image_url: this.getOptimizedImageUrl(post.image_path, post.image_url),
			}));
		} catch (error) {
			console.error(
				`‚ùå PostService.getPostsByCategory (Data API) error:`,
				error
			);
			return this.getPostsByCategorySDK(categoryId);
		}
	}

	// Post individual - Data API com cache longo
	static async getPostById(id) {
		if (!id) {
			throw new Error("Post ID √© obrigat√≥rio");
		}

		try {
			const postId = typeof id === "string" ? parseInt(id, 10) : id;

			if (isNaN(postId)) {
				throw new Error(`ID inv√°lido: ${id}`);
			}

			const data = await dataAPIService.getPostById(postId);

			// Otimizar URL da imagem para performance (tamanho maior para detalhes)
			return {
				...data,
				image_url: this.getOptimizedImageUrl(
					data.image_path,
					data.image_url,
					"1920x1080"
				),
			};
		} catch (error) {
			console.error("‚ùå PostService.getPostById (Data API) error:", error);

			if (error.message === "Post n√£o encontrado") {
				throw error;
			}

			return this.getPostByIdSDK(id);
		}
	}

	// Categorias - Data API com cache longo
	static async getCategories() {
		try {
			const data = await dataAPIService.getCategories();

			return data && data.length > 0 ? data : this.getFallbackCategories();
		} catch (error) {
			console.error("‚ùå PostService.getCategories (Data API) error:", error);
			return this.getFallbackCategories();
		}
	}

	// Busca de posts - Data API sem cache
	static async searchPosts(query) {
		if (!query || query.length < 2) {
			return [];
		}

		try {
			const data = await dataAPIService.searchPosts(query);

			// Otimizar URLs das imagens para performance
			return (data || []).map((post) => ({
				...post,
				image_url: this.getOptimizedImageUrl(post.image_path, post.image_url),
			}));
		} catch (error) {
			console.error("‚ùå PostService.searchPosts (Data API) error:", error);
			return this.searchPostsSDK(query);
		}
	}

	/**
	 * ======================================
	 * M√âTODOS FALLBACK - SDK (para compatibilidade)
	 * ======================================
	 */

	static async getFeaturedPostsSDK() {
		const freshClient = this.createFreshAnonymousClient();
		const { data, error } = await freshClient
			.from("posts")
			.select("*")
			.eq("published", true)
			.eq("trending", true)
			.order("created_at", { ascending: false })
			.limit(6);

		if (error) throw error;

		return (data || []).map((post) => ({
			...post,
			image_url: this.getOptimizedImageUrl(post.image_path, post.image_url),
		}));
	}

	static async getAllPostsSDK() {
		const freshClient = this.createFreshAnonymousClient();
		const { data, error } = await freshClient
			.from("posts")
			.select("*")
			.eq("published", true)
			.order("created_at", { ascending: false });

		if (error) throw error;

		return (data || []).map((post) => ({
			...post,
			image_url: this.getOptimizedImageUrl(post.image_path, post.image_url),
		}));
	}

	static async getPostsByCategorySDK(categoryId) {
		const freshClient = this.createFreshAnonymousClient();
		const { data, error } = await freshClient
			.from("posts")
			.select("*")
			.eq("published", true)
			.eq("category", categoryId)
			.order("created_at", { ascending: false });

		if (error) throw error;

		return (data || []).map((post) => ({
			...post,
			image_url: this.getOptimizedImageUrl(post.image_path, post.image_url),
		}));
	}

	static async getPostByIdSDK(id) {
		const postId = typeof id === "string" ? parseInt(id, 10) : id;
		const freshClient = this.createFreshAnonymousClient();
		const { data, error } = await freshClient
			.from("posts")
			.select("*")
			.eq("id", postId)
			.eq("published", true)
			.single();

		if (error) {
			if (error.code === "PGRST116") {
				throw new Error("Post n√£o encontrado");
			}
			throw error;
		}

		return {
			...data,
			image_url: this.getOptimizedImageUrl(
				data.image_path,
				data.image_url,
				"1920x1080"
			),
		};
	}

	static async searchPostsSDK(query) {
		const freshClient = this.createFreshAnonymousClient();
		const { data, error } = await freshClient
			.from("posts")
			.select("*")
			.eq("published", true)
			.or(
				`title.ilike.%${query}%,excerpt.ilike.%${query}%,content.ilike.%${query}%`
			)
			.order("created_at", { ascending: false })
			.limit(20);

		if (error) throw error;

		return (data || []).map((post) => ({
			...post,
			image_url: this.getOptimizedImageUrl(post.image_path, post.image_url),
		}));
	}

	/**
	 * ======================================
	 * M√âTODOS ADMINISTRATIVOS - VERS√ÉO CORRIGIDA E MELHORADA
	 * ======================================
	 */

	static async getAllPostsAdmin() {
		try {
			console.log("üìä PostService.getAllPostsAdmin: Iniciando busca...");

			const { data, error } = await adminClient
				.from("posts")
				.select("*")
				.order("created_at", { ascending: false });

			if (error) {
				console.error("‚ùå getAllPostsAdmin error:", error);
				throw error;
			}

			console.log(`‚úÖ getAllPostsAdmin: ${data?.length || 0} posts carregados`);

			// Para admin, manter URLs originais para edi√ß√£o
			return data || [];
		} catch (error) {
			console.error("‚ùå PostService.getAllPostsAdmin error:", error);
			throw new Error(`Erro ao carregar posts admin: ${error.message}`);
		}
	}

	static async getPostByIdAdmin(id) {
		if (!id) {
			throw new Error("Post ID √© obrigat√≥rio");
		}

		try {
			const postId = typeof id === "string" ? parseInt(id, 10) : id;

			if (isNaN(postId)) {
				throw new Error(`ID inv√°lido: ${id}`);
			}

			console.log(
				`üìñ PostService.getPostByIdAdmin: Buscando post ${postId}...`
			);

			const { data, error } = await adminClient
				.from("posts")
				.select("*")
				.eq("id", postId)
				.single();

			if (error) {
				if (error.code === "PGRST116") {
					throw new Error("Post n√£o encontrado");
				}
				console.error(`‚ùå getPostByIdAdmin(${postId}) error:`, error);
				throw error;
			}

			console.log(`‚úÖ getPostByIdAdmin: Post ${postId} carregado`);

			// Para admin, manter URLs originais para edi√ß√£o
			return data;
		} catch (error) {
			console.error("‚ùå PostService.getPostByIdAdmin error:", error);
			throw new Error(`Erro ao carregar post admin: ${error.message}`);
		}
	}

	// M√âTODO CREATEPOST - VERS√ÉO CORRIGIDA E COM DEBUG MELHORADO
	static async createPost(postData) {
		console.log("üÜï PostService.createPost: Iniciando cria√ß√£o de post...");
		console.log("üìù Dados recebidos:", {
			title: postData.title,
			slug: postData.slug,
			category: postData.category,
			image_url: postData.image_url ? "‚úÖ Presente" : "‚ùå Ausente",
			image_path: postData.image_path ? "‚úÖ Presente" : "‚ùå Ausente",
			published: postData.published,
			content_length: postData.content?.length || 0,
		});

		try {
			// VERIFICA√á√ÉO INICIAL: Conectividade e Auth
			const {
				data: { user },
			} = await adminClient.auth.getUser();
			console.log("üë§ Usu√°rio autenticado:", user ? "‚úÖ Sim" : "‚ùå N√£o");

			// TESTE DE CONEX√ÉO: Verificar se consegue fazer uma query simples
			const { data: testData, error: testError } = await adminClient
				.from("posts")
				.select("count")
				.limit(1);

			if (testError) {
				console.error("‚ùå Teste de conex√£o falhou:", testError);
				throw new Error(`Erro de conex√£o: ${testError.message}`);
			}

			console.log("üîó Conex√£o com banco de dados: ‚úÖ OK");

			// Validar dados obrigat√≥rios
			if (!postData.title) {
				throw new Error("T√≠tulo √© obrigat√≥rio");
			}

			if (!postData.image_url) {
				throw new Error("Imagem de capa √© obrigat√≥ria");
			}

			if (!postData.category) {
				throw new Error("Categoria √© obrigat√≥ria");
			}

			if (!postData.content || postData.content.trim() === "") {
				throw new Error("Conte√∫do √© obrigat√≥rio");
			}

			console.log("‚úÖ Valida√ß√µes b√°sicas: Aprovadas");

			// VERIFICAR ESTRUTURA DA TABELA (apenas em desenvolvimento)
			if (process.env.NODE_ENV === "development") {
				try {
					const { data: schemaData } = await adminClient
						.from("posts")
						.select("*")
						.limit(1);
					console.log("üìã Schema check: ‚úÖ Tabela acess√≠vel");
				} catch (schemaError) {
					console.warn("‚ö†Ô∏è Schema check failed:", schemaError);
				}
			}

			// Preparar dados para inser√ß√£o - INCLUINDO CAMPOS DE IMAGEM
			const dataToInsert = {
				// Campos b√°sicos
				title: postData.title.trim(),
				slug: postData.slug?.trim() || this.generateSlug(postData.title),
				excerpt: postData.excerpt?.trim() || "",
				content: postData.content.trim(),

				// CAMPOS DE IMAGEM - CR√çTICOS
				image_url: postData.image_url,
				image_path: postData.image_path || null,

				// Categoria e metadados
				category: postData.category,
				category_name: postData.category_name || "",

				// Metadados
				author: postData.author || "Equipe TF",
				read_time: postData.read_time || "5 min",

				// Estados
				published: Boolean(postData.published),
				trending: Boolean(postData.trending),

				// Tags
				tags: Array.isArray(postData.tags) ? postData.tags : [],

				// Timestamps
				created_at: new Date().toISOString(),
				updated_at: new Date().toISOString(),
			};

			// Verifica√ß√£o final
			if (!dataToInsert.image_url) {
				throw new Error("CR√çTICO: image_url n√£o foi definida");
			}

			console.log("üì§ Dados finais para inser√ß√£o:", {
				...dataToInsert,
				content: `${dataToInsert.content.substring(0, 100)}...`,
			});

			// REALIZAR INSER√á√ÉO
			console.log("üíæ Iniciando inser√ß√£o no banco de dados...");

			const { data, error } = await adminClient
				.from("posts")
				.insert([dataToInsert])
				.select()
				.single();

			if (error) {
				console.error("‚ùå Erro na inser√ß√£o:", error);
				console.error("üîç Detalhes do erro:", {
					code: error.code,
					message: error.message,
					details: error.details,
					hint: error.hint,
				});

				// Mensagens de erro espec√≠ficas
				if (error.message.includes("duplicate")) {
					throw new Error("J√° existe um post com este slug");
				} else if (error.message.includes("null value")) {
					throw new Error("Alguns campos obrigat√≥rios n√£o foram preenchidos");
				} else if (error.message.includes("foreign key")) {
					throw new Error("Categoria inv√°lida selecionada");
				} else if (
					error.message.includes("permission") ||
					error.code === "42501"
				) {
					throw new Error(
						"Erro de permiss√£o. Verifique se voc√™ tem acesso para criar posts"
					);
				} else if (error.message.includes("policy")) {
					throw new Error("Pol√≠tica de seguran√ßa bloqueou a opera√ß√£o");
				}

				throw new Error(`Erro na cria√ß√£o: ${error.message}`);
			}

			console.log("‚úÖ Post criado com sucesso!");
			console.log("üéâ Dados do post criado:", {
				id: data.id,
				title: data.title,
				slug: data.slug,
				published: data.published,
			});

			// Invalidar cache do Data API
			try {
				await this.invalidatePublicCache();
				console.log("üóëÔ∏è Cache invalidado com sucesso");
			} catch (cacheError) {
				console.warn("‚ö†Ô∏è Erro ao invalidar cache:", cacheError);
			}

			return data;
		} catch (error) {
			console.error("‚ùå PostService.createPost error:", error);

			// Log adicional para debug
			console.error("üîç Error details:", {
				name: error.name,
				message: error.message,
				stack: error.stack,
			});

			throw new Error(`Erro ao criar post: ${error.message}`);
		}
	}

	// M√âTODO UPDATEPOST - VERS√ÉO CORRIGIDA
	static async updatePost(id, postData) {
		console.log(`üìù PostService.updatePost: Atualizando post ${id}...`);

		try {
			const postId = typeof id === "string" ? parseInt(id, 10) : id;

			if (isNaN(postId)) {
				throw new Error(`ID inv√°lido: ${id}`);
			}

			// Validar dados obrigat√≥rios
			if (!postData.title) {
				throw new Error("T√≠tulo √© obrigat√≥rio");
			}

			if (!postData.image_url) {
				throw new Error("Imagem de capa √© obrigat√≥ria");
			}

			// Buscar post atual para comparar imagens
			const { data: currentPost } = await adminClient
				.from("posts")
				.select("image_path")
				.eq("id", postId)
				.single();

			// Preparar dados para atualiza√ß√£o - INCLUINDO CAMPOS DE IMAGEM
			const dataToUpdate = {
				// Campos b√°sicos
				title: postData.title,
				slug: postData.slug,
				excerpt: postData.excerpt,
				content: postData.content,

				// CAMPOS DE IMAGEM - CR√çTICOS
				image_url: postData.image_url,
				image_path: postData.image_path || null,

				// Categoria e metadados
				category: postData.category,
				category_name: postData.category_name,

				// Metadados
				author: postData.author || "Equipe TF",
				read_time: postData.read_time || "5 min",

				// Estados
				published: Boolean(postData.published),
				trending: Boolean(postData.trending),

				// Tags
				tags: Array.isArray(postData.tags) ? postData.tags : [],

				// Timestamp de atualiza√ß√£o
				updated_at: new Date().toISOString(),
			};

			// Verifica√ß√£o final
			if (!dataToUpdate.image_url) {
				throw new Error("CR√çTICO: image_url n√£o foi definida para atualiza√ß√£o");
			}

			console.log("üì§ Dados para atualiza√ß√£o:", {
				...dataToUpdate,
				content: `${dataToUpdate.content.substring(0, 100)}...`,
			});

			const { data, error } = await adminClient
				.from("posts")
				.update(dataToUpdate)
				.eq("id", postId)
				.select()
				.single();

			if (error) {
				console.error("‚ùå updatePost error:", error);

				// Mensagens de erro espec√≠ficas
				if (error.message.includes("duplicate")) {
					throw new Error("J√° existe um post com este slug");
				} else if (error.message.includes("null value")) {
					throw new Error("Alguns campos obrigat√≥rios n√£o foram preenchidos");
				} else if (error.message.includes("foreign key")) {
					throw new Error("Categoria inv√°lida selecionada");
				}

				throw error;
			}

			console.log("‚úÖ Post atualizado com sucesso!");

			// Se a imagem mudou, agendar limpeza da imagem antiga
			if (
				currentPost?.image_path &&
				currentPost.image_path !== postData.image_path &&
				postData.image_path // Se nova imagem foi definida
			) {
				this.scheduleImageCleanup(currentPost.image_path);
			}

			// Invalidar cache do Data API
			await this.invalidatePublicCache();

			return data;
		} catch (error) {
			console.error("‚ùå PostService.updatePost error:", error);
			throw new Error(`Erro ao atualizar post: ${error.message}`);
		}
	}

	static async deletePost(id) {
		try {
			const postId = typeof id === "string" ? parseInt(id, 10) : id;

			console.log(`üóëÔ∏è PostService.deletePost: Removendo post ${postId}...`);

			// Buscar imagem do post antes de deletar
			const { data: postToDelete } = await adminClient
				.from("posts")
				.select("image_path")
				.eq("id", postId)
				.single();

			const { error } = await adminClient
				.from("posts")
				.delete()
				.eq("id", postId);

			if (error) {
				console.error("‚ùå deletePost error:", error);
				throw error;
			}

			console.log("‚úÖ Post deletado com sucesso!");

			// Agendar limpeza da imagem
			if (postToDelete?.image_path) {
				this.scheduleImageCleanup(postToDelete.image_path);
			}

			// Invalidar cache do Data API
			await this.invalidatePublicCache();
		} catch (error) {
			console.error("‚ùå PostService.deletePost error:", error);
			throw new Error(`Erro ao deletar post: ${error.message}`);
		}
	}

	/**
	 * ======================================
	 * UTILITIES - OTIMIZA√á√ÉO DE IMAGENS
	 * ======================================
	 */

	/**
	 * Obter URL otimizada da imagem com fallback
	 */
	static getOptimizedImageUrl(imagePath, originalUrl, size = "800x600") {
		// Se temos image_path, usar URL otimizada
		if (imagePath) {
			return ImageUploadService.getOptimizedImageUrl(imagePath, size);
		}

		// Fallback para URL original (posts antigos)
		if (originalUrl) {
			return originalUrl;
		}

		// Fallback final para imagem padr√£o
		return "https://images.unsplash.com/photo-1558618666-fcd25c85cd64?w=800&h=600&fit=crop";
	}

	/**
	 * Gerar slug a partir do t√≠tulo
	 */
	static generateSlug(title) {
		if (!title) return `post-${Date.now()}`;

		return title
			.toLowerCase()
			.normalize("NFD")
			.replace(/[\u0300-\u036f]/g, "")
			.replace(/[^a-z0-9\s-]/g, "")
			.replace(/\s+/g, "-")
			.replace(/-+/g, "-")
			.trim();
	}

	/**
	 * Agendar limpeza de imagem antiga
	 */
	static scheduleImageCleanup(imagePath) {
		if (!imagePath) return;

		// Agendar limpeza com delay para evitar problemas de cache
		setTimeout(async () => {
			try {
				await ImageUploadService.removePostImage(imagePath);
				console.log(`üßπ Imagem antiga removida: ${imagePath}`);
			} catch (error) {
				console.warn("‚ö†Ô∏è Erro ao remover imagem antiga:", error);
			}
		}, 5 * 60 * 1000); // 5 minutos de delay
	}

	static createFreshAnonymousClient() {
		return createClient(supabaseUrl, supabaseAnonKey, {
			auth: {
				persistSession: false,
				autoRefreshToken: false,
				detectSessionInUrl: false,
				storageKey: `supabase.auth.token.anonymous.${Date.now()}`,
			},
		});
	}

	static async invalidatePublicCache() {
		try {
			// Invalidar cache HTTP das principais rotas
			await Promise.all([
				dataAPIService.invalidateCache("/posts"),
				dataAPIService.invalidateCache("/categories"),
			]);
		} catch (error) {
			console.warn("Cache invalidation failed:", error);
		}
	}

	static getFallbackCategories() {
		return [
			{
				id: "f1",
				name: "F√≥rmula 1",
				description: "A elite do automobilismo mundial",
				color: "from-red-500 to-orange-500",
			},
			{
				id: "nascar",
				name: "NASCAR",
				description: "A categoria mais popular dos EUA",
				color: "from-blue-500 to-cyan-500",
			},
			{
				id: "endurance",
				name: "Endurance",
				description: "Corridas de resist√™ncia √©picas",
				color: "from-green-500 to-emerald-500",
			},
			{
				id: "drift",
				name: "Formula Drift",
				description: "A arte de deslizar com estilo",
				color: "from-purple-500 to-pink-500",
			},
			{
				id: "tuning",
				name: "Tuning & Custom",
				description: "Personaliza√ß√£o e modifica√ß√µes",
				color: "from-yellow-500 to-orange-500",
			},
			{
				id: "engines",
				name: "Motores",
				description: "Tecnologia e performance",
				color: "from-indigo-500 to-purple-500",
			},
		];
	}

	/**
	 * ======================================
	 * M√âTODOS DE DEBUG E DIAGN√ìSTICO
	 * ======================================
	 */

	// Verificar schema da tabela posts
	static async debugTableSchema() {
		try {
			console.log("üîç Verificando schema da tabela posts...");

			const { data, error } = await adminClient
				.from("posts")
				.select("*")
				.limit(1);

			if (error) {
				console.error("‚ùå Erro ao verificar schema:", error);
				return { success: false, error };
			}

			const columns = data.length > 0 ? Object.keys(data[0]) : [];
			console.log("üìã Colunas da tabela posts:", columns);

			return { success: true, columns, sampleData: data[0] };
		} catch (error) {
			console.error("‚ùå debugTableSchema error:", error);
			return { success: false, error };
		}
	}

	// Testar inser√ß√£o simples
	static async debugTestInsert() {
		try {
			console.log("üß™ Testando inser√ß√£o simples...");

			const testData = {
				title: "Post de Teste",
				slug: "post-de-teste-" + Date.now(),
				excerpt: "Este √© um post de teste",
				content: "Conte√∫do do post de teste",
				image_url: "https://example.com/test.jpg",
				image_path: "test/image.jpg",
				category: "f1",
				category_name: "F√≥rmula 1",
				author: "Admin",
				read_time: "5 min",
				published: false,
				trending: false,
				tags: ["teste"],
				created_at: new Date().toISOString(),
				updated_at: new Date().toISOString(),
			};

			const { data, error } = await adminClient
				.from("posts")
				.insert([testData])
				.select()
				.single();

			if (error) {
				console.error("‚ùå debugTestInsert error:", error);
				return { success: false, error };
			}

			console.log("‚úÖ Teste de inser√ß√£o bem-sucedido:", data);

			// Limpar teste
			await adminClient.from("posts").delete().eq("id", data.id);
			console.log("üßπ Post de teste removido");

			return { success: true, data };
		} catch (error) {
			console.error("‚ùå debugTestInsert error:", error);
			return { success: false, error };
		}
	}

	// Verificar permiss√µes RLS
	static async debugCheckPermissions() {
		try {
			console.log("üîê Verificando permiss√µes...");

			// Tentar diferentes opera√ß√µes
			const tests = {
				select: false,
				insert: false,
				update: false,
				delete: false,
			};

			// Teste SELECT
			try {
				await adminClient.from("posts").select("id").limit(1);
				tests.select = true;
			} catch (error) {
				console.warn("‚ö†Ô∏è SELECT falhou:", error.message);
			}

			// Teste INSERT (com dados de teste)
			try {
				const { data, error } = await adminClient
					.from("posts")
					.insert([
						{
							title: "Teste Permiss√£o",
							slug: "teste-permissao-" + Date.now(),
							excerpt: "Teste",
							content: "Teste",
							image_url: "https://example.com/test.jpg",
							category: "f1",
							published: false,
						},
					])
					.select()
					.single();

				if (!error) {
					tests.insert = true;
					// Limpar imediatamente
					await adminClient.from("posts").delete().eq("id", data.id);
				}
			} catch (error) {
				console.warn("‚ö†Ô∏è INSERT falhou:", error.message);
			}

			console.log("üîê Resultados dos testes de permiss√£o:", tests);
			return tests;
		} catch (error) {
			console.error("‚ùå debugCheckPermissions error:", error);
			return { error };
		}
	}

	// M√©todo principal de diagn√≥stico
	static async runDiagnostics() {
		console.log("ü©∫ Iniciando diagn√≥sticos completos...");

		const results = {
			timestamp: new Date().toISOString(),
			schema: await this.debugTableSchema(),
			permissions: await this.debugCheckPermissions(),
			testInsert: await this.debugTestInsert(),
		};

		console.log("üìä Relat√≥rio de diagn√≥sticos:", results);
		return results;
	}
}
